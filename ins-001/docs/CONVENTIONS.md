# Implementation Conventions - INS-001

**READ THIS FIRST BEFORE WRITING ANY CODE**

This document defines the rules for implementing INS-001. Following these conventions prevents bugs, security vulnerabilities, and construct validity issues.

---

## üö® CRITICAL RULES (Never Violate)

### 1. NEVER Use Service Key in Route Handlers

```python
# ‚ùå WRONG - Bypasses all RLS, anyone can read any data
supabase = create_client(URL, SERVICE_KEY)

# ‚úÖ CORRECT - Uses user JWT, RLS enforced
supabase, user = await get_authenticated_client(credentials)
```

The service key is ONLY for background jobs (profile computation, cleanup).

### 2. Word Validation Rules (IMPORTANT)

Seed words and clues/guesses have DIFFERENT validation rules:

#### Seed Words: OPEN (no restrictions)

```python
# ‚úÖ CORRECT - No validation needed for seed words
seed_word = request.seed_word.lower().strip()
# Just use it directly

# ‚ùå WRONG - Don't validate seed against vocabulary
if not await validate_word(supabase, request.seed_word):
    raise HTTPException(400, "Word not in vocabulary")
```

Users can enter ANY seed word:
- Standard English words
- Domain-specific terms (tachycardia, estoppel)
- Proper nouns (Shakespeare, Obi-Wan)
- Slang and neologisms (rizz, skibidi)
- Foreign words
- Made-up words
- Yes, even offensive words (it's a private game between consenting players)

MVP rationale: Seed never enters LLM prompt, only visible to two players who opted in, no legal requirement to filter.

#### Clues and Guesses: CLOSED (vocabulary only)

```python
# ‚úÖ CORRECT - Validate clues/guesses against vocabulary
all_valid, invalid = await validate_words(supabase, request.clues)
if not all_valid:
    raise HTTPException(400, f"Invalid clues: {', '.join(invalid)}")
```

Why the difference?
1. **Seed word:** Never enters LLM prompt (it's the hidden answer), no injection risk
2. **Clues:** Go to LLM prompt, must be validated for prompt safety
3. **Guesses:** Need reliable embeddings for scoring

#### Tracking for Analytics

```python
# Track for research filtering, don't block
seed_in_vocabulary = await check_word_in_vocabulary(supabase, seed_word)
```

### 3. NEVER Use Service Key in Route Handlers

Storage uses 16-bit floats to fit in Supabase Free tier:

```sql
-- ‚ùå WRONG - Uses 300MB
embedding vector(1536)

-- ‚úÖ CORRECT - Uses 150MB  
embedding halfvec(1536)
```

Index must use `halfvec_cosine_ops`:

```sql
-- ‚ùå WRONG
USING ivfflat (embedding vector_cosine_ops)

-- ‚úÖ CORRECT
USING ivfflat (embedding halfvec_cosine_ops)
```

### 4. Lock Rows to Prevent Race Conditions

When updating shared resources, use `FOR UPDATE`:

```sql
-- ‚ùå WRONG - Race condition on concurrent joins
SELECT game_id FROM share_tokens WHERE token = $1

-- ‚úÖ CORRECT - Locks row until transaction completes
SELECT game_id FROM share_tokens WHERE token = $1 FOR UPDATE
```

---

## API Conventions

### Request/Response Shapes

Use ONLY the models defined in `app/models.py`. Do not invent new fields.

### Error Responses

Always return `ErrorResponse`:

```python
raise HTTPException(
    status_code=400,
    detail=ErrorResponse(error="Word not in vocabulary", detail="'asdf' is not a valid word").dict()
)
```

### Status Codes

| Code | Use |
|------|-----|
| 200 | Success |
| 400 | Bad request (validation error) |
| 401 | Not authenticated |
| 403 | Not authorized (RLS blocked) |
| 404 | Resource not found |
| 500 | Server error |

---

## Database Conventions

### Table Names

Lowercase, plural: `games`, `users`, `share_tokens`

### Column Names  

Lowercase, snake_case: `seed_word`, `created_at`, `divergence_score`

### UUIDs

All primary keys are UUIDs, generated by Postgres:

```sql
id UUID PRIMARY KEY DEFAULT gen_random_uuid()
```

### Timestamps

Always use `TIMESTAMPTZ`, never `TIMESTAMP`:

```sql
created_at TIMESTAMPTZ DEFAULT NOW()
```

### Foreign Keys

Always include `ON DELETE CASCADE` for child tables:

```sql
REFERENCES users(id) ON DELETE CASCADE
```

---

## Embedding Conventions

### Model

Always use `text-embedding-3-small`. Do not use other models.

### Contextual Embeddings

For scoring (divergence/convergence), always include context:

```python
# ‚ùå WRONG - No context, polysemy issues
embedding = await get_embedding(word)

# ‚úÖ CORRECT - Context disambiguates meaning
embedding = await get_contextual_embedding(word, context=[seed_word])
```

### Noise Floor

Noise floor uses precomputed embeddings (fast), not contextual:

```python
# Noise floor: precomputed, <100ms
floor = await get_noise_floor(supabase, seed_word)

# Scoring: contextual, ~300ms
clue_emb = await get_contextual_embedding(clue, [seed_word])
```

---

## Scoring Conventions

### Divergence Formula

```
divergence = 1 - mean(cosine_similarity(clue, floor_centroid))
```

Range: [0, 1]. Higher = more creative.

### Convergence Formula

```
convergence = max(cosine_similarity(guess, seed))
```

With exact match bonus: if guess == seed, return 1.0

Range: [0, 1]. Higher = better communication.

### DO NOT modify these formulas. They define the construct validity.

---

## LLM Conventions

### Model

Always use `claude-3-5-haiku-20241022`. Do not use other models.

Changing models affects construct validity (LLM Alignment metric).

### Prompt Structure

Always isolate user content in XML tags:

```python
# ‚ùå WRONG - Prompt injection risk
prompt = f"Clues: {', '.join(clues)}"

# ‚úÖ CORRECT - User content isolated
prompt = f"""
<clues>
{chr(10).join(f'  <clue>{html.escape(c)}</clue>' for c in clues)}
</clues>
"""
```

### Temperature

Use 0.3 for guessing (some variety, mostly consistent).

---

## File Organization

```
app/
‚îú‚îÄ‚îÄ main.py              # FastAPI app, routes mounted here
‚îú‚îÄ‚îÄ config.py            # Environment variables
‚îú‚îÄ‚îÄ models.py            # Pydantic models (DO NOT MODIFY SHAPES)
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îî‚îÄ‚îÄ auth.py          # JWT validation (CRITICAL)
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ games.py         # Game CRUD endpoints
‚îÇ   ‚îú‚îÄ‚îÄ embeddings.py    # Noise floor, validation
‚îÇ   ‚îú‚îÄ‚îÄ users.py         # User profile endpoints
‚îÇ   ‚îî‚îÄ‚îÄ share.py         # Share token endpoints
‚îî‚îÄ‚îÄ services/
    ‚îú‚îÄ‚îÄ embeddings.py    # OpenAI integration
    ‚îú‚îÄ‚îÄ scoring.py       # Divergence/convergence math
    ‚îú‚îÄ‚îÄ llm.py           # Claude guesser
    ‚îî‚îÄ‚îÄ profiles.py      # Profile computation
```

---

## Testing Conventions

### Run scoring tests before any changes:

```bash
python -m pytest app/services/scoring.py -v
```

### Test auth middleware:

```bash
# Should fail with 401
curl -X GET http://localhost:8000/api/v1/users/me

# Should succeed with valid token
curl -X GET http://localhost:8000/api/v1/users/me \
  -H "Authorization: Bearer <token>"
```

---

## Environment Variables

Required in `.env`:

```
SUPABASE_URL=https://xxx.supabase.co
SUPABASE_ANON_KEY=eyJ...        # Safe to expose
SUPABASE_SERVICE_KEY=eyJ...     # NEVER expose, only for background jobs
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
POSTHOG_API_KEY=phc_...
SENTRY_DSN=https://...
```

---

---

## Open Seed Words: Design Rationale

### Why Seeds Are Completely Open

1. **UX:** Users can use domain-specific terms, proper nouns, slang, anything
2. **Safety:** Seed never enters LLM prompt (it's the hidden answer)
3. **Scoring:** OpenAI embeds any string via subword tokenization
4. **Self-correcting:** Gibberish seeds produce weak games, not crashes
5. **Private:** Only visible to two consenting players, not public content
6. **Legal:** No requirement to filter (Section 230 protects platforms)

### Why Clues/Guesses Are Closed

1. **Prompt safety:** Clues go directly to LLM prompt
2. **Scoring validity:** Guesses need reliable embeddings
3. **Data quality:** Vocabulary-constrained data is cleaner for research

### Fuzzy Exact Match

For convergence scoring, we treat >99% embedding similarity as exact match.
This handles misspellings and alternate spellings (Ghandi/Gandhi).

```python
FUZZY_EXACT_MATCH_THRESHOLD = 0.99

if max_similarity > FUZZY_EXACT_MATCH_THRESHOLD:
    return 1.0, True  # Treat as exact match
```

### Analytics Tracking

Games track `seed_in_vocabulary` for research filtering:

```sql
-- Filter to vocabulary-only seeds for strict validity
SELECT * FROM games WHERE seed_in_vocabulary = TRUE;

-- Analyze open seeds separately
SELECT * FROM games WHERE seed_in_vocabulary = FALSE;
```

---

## Common Mistakes to Avoid

| Mistake | Consequence | Fix |
|---------|-------------|-----|
| Using service key in routes | RLS bypassed, data breach | Use `get_authenticated_client()` |
| Using `vector` instead of `halfvec` | Exceeds 500MB limit | Use `halfvec(1536)` |
| Validating seed against vocabulary | Blocks valid use cases | Accept any seed word |
| NOT validating clues/guesses | Prompt injection, bad scores | Call `validate_words()` |
| Modifying scoring formulas | Breaks construct validity | Use exact formulas |
| Changing LLM model | Breaks LLM Alignment metric | Use Haiku only |
| Missing `FOR UPDATE` | Race conditions | Add to shared resource queries |
| Trusting user input in prompts | Prompt injection | XML-escape and isolate |
| Forgetting fuzzy exact match | Misspellings score wrong | Use `FUZZY_EXACT_MATCH_THRESHOLD` |
